
1_Interrupciones.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000026  00802000  00000c98  00000d2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003a  00802026  00802026  00000d52  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d52  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d84  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001d8  00000000  00000000  00000dc8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000275d  00000000  00000000  00000fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000006bd  00000000  00000000  000036fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000215e  00000000  00000000  00003dba  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000aa8  00000000  00000000  00005f18  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000257ed  00000000  00000000  000069c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001997  00000000  00000000  0002c1ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  0002db44  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00008b21  00000000  00000000  0002dcbc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	fd c0       	rjmp	.+506    	; 0x1fc <__ctors_end>
   2:	00 00       	nop
   4:	16 c1       	rjmp	.+556    	; 0x232 <__bad_interrupt>
   6:	00 00       	nop
   8:	14 c1       	rjmp	.+552    	; 0x232 <__bad_interrupt>
   a:	00 00       	nop
   c:	12 c1       	rjmp	.+548    	; 0x232 <__bad_interrupt>
   e:	00 00       	nop
  10:	10 c1       	rjmp	.+544    	; 0x232 <__bad_interrupt>
  12:	00 00       	nop
  14:	0e c1       	rjmp	.+540    	; 0x232 <__bad_interrupt>
  16:	00 00       	nop
  18:	0c c1       	rjmp	.+536    	; 0x232 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	0a c1       	rjmp	.+532    	; 0x232 <__bad_interrupt>
  1e:	00 00       	nop
  20:	08 c1       	rjmp	.+528    	; 0x232 <__bad_interrupt>
  22:	00 00       	nop
  24:	06 c1       	rjmp	.+524    	; 0x232 <__bad_interrupt>
  26:	00 00       	nop
  28:	04 c1       	rjmp	.+520    	; 0x232 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	02 c1       	rjmp	.+516    	; 0x232 <__bad_interrupt>
  2e:	00 00       	nop
  30:	00 c1       	rjmp	.+512    	; 0x232 <__bad_interrupt>
  32:	00 00       	nop
  34:	fe c0       	rjmp	.+508    	; 0x232 <__bad_interrupt>
  36:	00 00       	nop
  38:	fd c0       	rjmp	.+506    	; 0x234 <__vector_14>
  3a:	00 00       	nop
  3c:	24 c1       	rjmp	.+584    	; 0x286 <__vector_15>
  3e:	00 00       	nop
  40:	4b c1       	rjmp	.+662    	; 0x2d8 <__vector_16>
  42:	00 00       	nop
  44:	72 c1       	rjmp	.+740    	; 0x32a <__vector_17>
  46:	00 00       	nop
  48:	99 c1       	rjmp	.+818    	; 0x37c <__vector_18>
  4a:	00 00       	nop
  4c:	c0 c1       	rjmp	.+896    	; 0x3ce <__vector_19>
  4e:	00 00       	nop
  50:	e7 c1       	rjmp	.+974    	; 0x420 <__vector_20>
  52:	00 00       	nop
  54:	0e c2       	rjmp	.+1052   	; 0x472 <__vector_21>
  56:	00 00       	nop
  58:	35 c2       	rjmp	.+1130   	; 0x4c4 <__vector_22>
  5a:	00 00       	nop
  5c:	5c c2       	rjmp	.+1208   	; 0x516 <__vector_23>
  5e:	00 00       	nop
  60:	e8 c0       	rjmp	.+464    	; 0x232 <__bad_interrupt>
  62:	00 00       	nop
  64:	e6 c0       	rjmp	.+460    	; 0x232 <__bad_interrupt>
  66:	00 00       	nop
  68:	e4 c0       	rjmp	.+456    	; 0x232 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	e2 c0       	rjmp	.+452    	; 0x232 <__bad_interrupt>
  6e:	00 00       	nop
  70:	e0 c0       	rjmp	.+448    	; 0x232 <__bad_interrupt>
  72:	00 00       	nop
  74:	de c0       	rjmp	.+444    	; 0x232 <__bad_interrupt>
  76:	00 00       	nop
  78:	dc c0       	rjmp	.+440    	; 0x232 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	da c0       	rjmp	.+436    	; 0x232 <__bad_interrupt>
  7e:	00 00       	nop
  80:	d8 c0       	rjmp	.+432    	; 0x232 <__bad_interrupt>
  82:	00 00       	nop
  84:	d6 c0       	rjmp	.+428    	; 0x232 <__bad_interrupt>
  86:	00 00       	nop
  88:	d4 c0       	rjmp	.+424    	; 0x232 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	d2 c0       	rjmp	.+420    	; 0x232 <__bad_interrupt>
  8e:	00 00       	nop
  90:	d0 c0       	rjmp	.+416    	; 0x232 <__bad_interrupt>
  92:	00 00       	nop
  94:	ce c0       	rjmp	.+412    	; 0x232 <__bad_interrupt>
  96:	00 00       	nop
  98:	cc c0       	rjmp	.+408    	; 0x232 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	ca c0       	rjmp	.+404    	; 0x232 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	c8 c0       	rjmp	.+400    	; 0x232 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	c6 c0       	rjmp	.+396    	; 0x232 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	c4 c0       	rjmp	.+392    	; 0x232 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	c2 c0       	rjmp	.+388    	; 0x232 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	c0 c0       	rjmp	.+384    	; 0x232 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	be c0       	rjmp	.+380    	; 0x232 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	bc c0       	rjmp	.+376    	; 0x232 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	ef c3       	rjmp	.+2014   	; 0x89c <__vector_47>
  be:	00 00       	nop
  c0:	16 c4       	rjmp	.+2092   	; 0x8ee <__vector_48>
  c2:	00 00       	nop
  c4:	3d c4       	rjmp	.+2170   	; 0x940 <__vector_49>
  c6:	00 00       	nop
  c8:	64 c4       	rjmp	.+2248   	; 0x992 <__vector_50>
  ca:	00 00       	nop
  cc:	8b c4       	rjmp	.+2326   	; 0x9e4 <__vector_51>
  ce:	00 00       	nop
  d0:	b2 c4       	rjmp	.+2404   	; 0xa36 <__vector_52>
  d2:	00 00       	nop
  d4:	ae c0       	rjmp	.+348    	; 0x232 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	ac c0       	rjmp	.+344    	; 0x232 <__bad_interrupt>
  da:	00 00       	nop
  dc:	aa c0       	rjmp	.+340    	; 0x232 <__bad_interrupt>
  de:	00 00       	nop
  e0:	a8 c0       	rjmp	.+336    	; 0x232 <__bad_interrupt>
  e2:	00 00       	nop
  e4:	a6 c0       	rjmp	.+332    	; 0x232 <__bad_interrupt>
  e6:	00 00       	nop
  e8:	a4 c0       	rjmp	.+328    	; 0x232 <__bad_interrupt>
  ea:	00 00       	nop
  ec:	a2 c0       	rjmp	.+324    	; 0x232 <__bad_interrupt>
  ee:	00 00       	nop
  f0:	a0 c0       	rjmp	.+320    	; 0x232 <__bad_interrupt>
  f2:	00 00       	nop
  f4:	9e c0       	rjmp	.+316    	; 0x232 <__bad_interrupt>
  f6:	00 00       	nop
  f8:	9c c0       	rjmp	.+312    	; 0x232 <__bad_interrupt>
  fa:	00 00       	nop
  fc:	9a c0       	rjmp	.+308    	; 0x232 <__bad_interrupt>
  fe:	00 00       	nop
 100:	98 c0       	rjmp	.+304    	; 0x232 <__bad_interrupt>
 102:	00 00       	nop
 104:	96 c0       	rjmp	.+300    	; 0x232 <__bad_interrupt>
 106:	00 00       	nop
 108:	02 c5       	rjmp	.+2564   	; 0xb0e <__vector_66>
 10a:	00 00       	nop
 10c:	51 c5       	rjmp	.+2722   	; 0xbb0 <__vector_67>
 10e:	00 00       	nop
 110:	90 c0       	rjmp	.+288    	; 0x232 <__bad_interrupt>
 112:	00 00       	nop
 114:	8e c0       	rjmp	.+284    	; 0x232 <__bad_interrupt>
 116:	00 00       	nop
 118:	8c c0       	rjmp	.+280    	; 0x232 <__bad_interrupt>
 11a:	00 00       	nop
 11c:	8a c0       	rjmp	.+276    	; 0x232 <__bad_interrupt>
 11e:	00 00       	nop
 120:	88 c0       	rjmp	.+272    	; 0x232 <__bad_interrupt>
 122:	00 00       	nop
 124:	86 c0       	rjmp	.+268    	; 0x232 <__bad_interrupt>
 126:	00 00       	nop
 128:	84 c0       	rjmp	.+264    	; 0x232 <__bad_interrupt>
 12a:	00 00       	nop
 12c:	82 c0       	rjmp	.+260    	; 0x232 <__bad_interrupt>
 12e:	00 00       	nop
 130:	80 c0       	rjmp	.+256    	; 0x232 <__bad_interrupt>
 132:	00 00       	nop
 134:	19 c2       	rjmp	.+1074   	; 0x568 <__vector_77>
 136:	00 00       	nop
 138:	40 c2       	rjmp	.+1152   	; 0x5ba <__vector_78>
 13a:	00 00       	nop
 13c:	67 c2       	rjmp	.+1230   	; 0x60c <__vector_79>
 13e:	00 00       	nop
 140:	8e c2       	rjmp	.+1308   	; 0x65e <__vector_80>
 142:	00 00       	nop
 144:	b5 c2       	rjmp	.+1386   	; 0x6b0 <__vector_81>
 146:	00 00       	nop
 148:	dc c2       	rjmp	.+1464   	; 0x702 <__vector_82>
 14a:	00 00       	nop
 14c:	03 c3       	rjmp	.+1542   	; 0x754 <__vector_83>
 14e:	00 00       	nop
 150:	2a c3       	rjmp	.+1620   	; 0x7a6 <__vector_84>
 152:	00 00       	nop
 154:	51 c3       	rjmp	.+1698   	; 0x7f8 <__vector_85>
 156:	00 00       	nop
 158:	78 c3       	rjmp	.+1776   	; 0x84a <__vector_86>
 15a:	00 00       	nop
 15c:	6a c0       	rjmp	.+212    	; 0x232 <__bad_interrupt>
 15e:	00 00       	nop
 160:	68 c0       	rjmp	.+208    	; 0x232 <__bad_interrupt>
 162:	00 00       	nop
 164:	66 c0       	rjmp	.+204    	; 0x232 <__bad_interrupt>
 166:	00 00       	nop
 168:	64 c0       	rjmp	.+200    	; 0x232 <__bad_interrupt>
 16a:	00 00       	nop
 16c:	62 c0       	rjmp	.+196    	; 0x232 <__bad_interrupt>
 16e:	00 00       	nop
 170:	60 c0       	rjmp	.+192    	; 0x232 <__bad_interrupt>
 172:	00 00       	nop
 174:	5e c0       	rjmp	.+188    	; 0x232 <__bad_interrupt>
 176:	00 00       	nop
 178:	5c c0       	rjmp	.+184    	; 0x232 <__bad_interrupt>
 17a:	00 00       	nop
 17c:	5a c0       	rjmp	.+180    	; 0x232 <__bad_interrupt>
 17e:	00 00       	nop
 180:	58 c0       	rjmp	.+176    	; 0x232 <__bad_interrupt>
 182:	00 00       	nop
 184:	56 c0       	rjmp	.+172    	; 0x232 <__bad_interrupt>
 186:	00 00       	nop
 188:	54 c0       	rjmp	.+168    	; 0x232 <__bad_interrupt>
 18a:	00 00       	nop
 18c:	52 c0       	rjmp	.+164    	; 0x232 <__bad_interrupt>
 18e:	00 00       	nop
 190:	50 c0       	rjmp	.+160    	; 0x232 <__bad_interrupt>
 192:	00 00       	nop
 194:	4e c0       	rjmp	.+156    	; 0x232 <__bad_interrupt>
 196:	00 00       	nop
 198:	4c c0       	rjmp	.+152    	; 0x232 <__bad_interrupt>
 19a:	00 00       	nop
 19c:	4a c0       	rjmp	.+148    	; 0x232 <__bad_interrupt>
 19e:	00 00       	nop
 1a0:	48 c0       	rjmp	.+144    	; 0x232 <__bad_interrupt>
 1a2:	00 00       	nop
 1a4:	46 c0       	rjmp	.+140    	; 0x232 <__bad_interrupt>
 1a6:	00 00       	nop
 1a8:	44 c0       	rjmp	.+136    	; 0x232 <__bad_interrupt>
 1aa:	00 00       	nop
 1ac:	42 c0       	rjmp	.+132    	; 0x232 <__bad_interrupt>
 1ae:	00 00       	nop
 1b0:	40 c0       	rjmp	.+128    	; 0x232 <__bad_interrupt>
 1b2:	00 00       	nop
 1b4:	3e c0       	rjmp	.+124    	; 0x232 <__bad_interrupt>
 1b6:	00 00       	nop
 1b8:	3c c0       	rjmp	.+120    	; 0x232 <__bad_interrupt>
 1ba:	00 00       	nop
 1bc:	3a c0       	rjmp	.+116    	; 0x232 <__bad_interrupt>
 1be:	00 00       	nop
 1c0:	38 c0       	rjmp	.+112    	; 0x232 <__bad_interrupt>
 1c2:	00 00       	nop
 1c4:	36 c0       	rjmp	.+108    	; 0x232 <__bad_interrupt>
 1c6:	00 00       	nop
 1c8:	34 c0       	rjmp	.+104    	; 0x232 <__bad_interrupt>
 1ca:	00 00       	nop
 1cc:	32 c0       	rjmp	.+100    	; 0x232 <__bad_interrupt>
 1ce:	00 00       	nop
 1d0:	30 c0       	rjmp	.+96     	; 0x232 <__bad_interrupt>
 1d2:	00 00       	nop
 1d4:	2e c0       	rjmp	.+92     	; 0x232 <__bad_interrupt>
 1d6:	00 00       	nop
 1d8:	2c c0       	rjmp	.+88     	; 0x232 <__bad_interrupt>
 1da:	00 00       	nop
 1dc:	2a c0       	rjmp	.+84     	; 0x232 <__bad_interrupt>
 1de:	00 00       	nop
 1e0:	28 c0       	rjmp	.+80     	; 0x232 <__bad_interrupt>
 1e2:	00 00       	nop
 1e4:	26 c0       	rjmp	.+76     	; 0x232 <__bad_interrupt>
 1e6:	00 00       	nop
 1e8:	24 c0       	rjmp	.+72     	; 0x232 <__bad_interrupt>
 1ea:	00 00       	nop
 1ec:	22 c0       	rjmp	.+68     	; 0x232 <__bad_interrupt>
 1ee:	00 00       	nop
 1f0:	20 c0       	rjmp	.+64     	; 0x232 <__bad_interrupt>
 1f2:	00 00       	nop
 1f4:	1e c0       	rjmp	.+60     	; 0x232 <__bad_interrupt>
 1f6:	00 00       	nop
 1f8:	1c c0       	rjmp	.+56     	; 0x232 <__bad_interrupt>
	...

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e2       	ldi	r29, 0x2F	; 47
 206:	de bf       	out	0x3e, r29	; 62

00000208 <__do_copy_data>:
 208:	10 e2       	ldi	r17, 0x20	; 32
 20a:	a0 e0       	ldi	r26, 0x00	; 0
 20c:	b0 e2       	ldi	r27, 0x20	; 32
 20e:	e8 e9       	ldi	r30, 0x98	; 152
 210:	fc e0       	ldi	r31, 0x0C	; 12
 212:	02 c0       	rjmp	.+4      	; 0x218 <__do_copy_data+0x10>
 214:	05 90       	lpm	r0, Z+
 216:	0d 92       	st	X+, r0
 218:	a6 32       	cpi	r26, 0x26	; 38
 21a:	b1 07       	cpc	r27, r17
 21c:	d9 f7       	brne	.-10     	; 0x214 <__do_copy_data+0xc>

0000021e <__do_clear_bss>:
 21e:	20 e2       	ldi	r18, 0x20	; 32
 220:	a6 e2       	ldi	r26, 0x26	; 38
 222:	b0 e2       	ldi	r27, 0x20	; 32
 224:	01 c0       	rjmp	.+2      	; 0x228 <.do_clear_bss_start>

00000226 <.do_clear_bss_loop>:
 226:	1d 92       	st	X+, r1

00000228 <.do_clear_bss_start>:
 228:	a0 36       	cpi	r26, 0x60	; 96
 22a:	b2 07       	cpc	r27, r18
 22c:	e1 f7       	brne	.-8      	; 0x226 <.do_clear_bss_loop>
 22e:	10 d5       	rcall	.+2592   	; 0xc50 <main>
 230:	31 c5       	rjmp	.+2658   	; 0xc94 <_exit>

00000232 <__bad_interrupt>:
 232:	e6 ce       	rjmp	.-564    	; 0x0 <__vectors>

00000234 <__vector_14>:
 *
 * This function will handle interrupt on Timer Counter CO overflow and
 * call the callback function.
 */
ISR(TCC0_OVF_vect)
{
 234:	1f 92       	push	r1
 236:	0f 92       	push	r0
 238:	0f b6       	in	r0, 0x3f	; 63
 23a:	0f 92       	push	r0
 23c:	11 24       	eor	r1, r1
 23e:	2f 93       	push	r18
 240:	3f 93       	push	r19
 242:	4f 93       	push	r20
 244:	5f 93       	push	r21
 246:	6f 93       	push	r22
 248:	7f 93       	push	r23
 24a:	8f 93       	push	r24
 24c:	9f 93       	push	r25
 24e:	af 93       	push	r26
 250:	bf 93       	push	r27
 252:	ef 93       	push	r30
 254:	ff 93       	push	r31
	if (tc_tcc0_ovf_callback) {
 256:	e0 91 58 20 	lds	r30, 0x2058
 25a:	f0 91 59 20 	lds	r31, 0x2059
 25e:	30 97       	sbiw	r30, 0x00	; 0
 260:	09 f0       	breq	.+2      	; 0x264 <__vector_14+0x30>
		tc_tcc0_ovf_callback();
 262:	09 95       	icall
	}
}
 264:	ff 91       	pop	r31
 266:	ef 91       	pop	r30
 268:	bf 91       	pop	r27
 26a:	af 91       	pop	r26
 26c:	9f 91       	pop	r25
 26e:	8f 91       	pop	r24
 270:	7f 91       	pop	r23
 272:	6f 91       	pop	r22
 274:	5f 91       	pop	r21
 276:	4f 91       	pop	r20
 278:	3f 91       	pop	r19
 27a:	2f 91       	pop	r18
 27c:	0f 90       	pop	r0
 27e:	0f be       	out	0x3f, r0	; 63
 280:	0f 90       	pop	r0
 282:	1f 90       	pop	r1
 284:	18 95       	reti

00000286 <__vector_15>:
 *
 * This function will handle interrupt on Timer Counter CO error and
 * call the callback function.
 */
ISR(TCC0_ERR_vect)
{
 286:	1f 92       	push	r1
 288:	0f 92       	push	r0
 28a:	0f b6       	in	r0, 0x3f	; 63
 28c:	0f 92       	push	r0
 28e:	11 24       	eor	r1, r1
 290:	2f 93       	push	r18
 292:	3f 93       	push	r19
 294:	4f 93       	push	r20
 296:	5f 93       	push	r21
 298:	6f 93       	push	r22
 29a:	7f 93       	push	r23
 29c:	8f 93       	push	r24
 29e:	9f 93       	push	r25
 2a0:	af 93       	push	r26
 2a2:	bf 93       	push	r27
 2a4:	ef 93       	push	r30
 2a6:	ff 93       	push	r31
	if (tc_tcc0_err_callback) {
 2a8:	e0 91 56 20 	lds	r30, 0x2056
 2ac:	f0 91 57 20 	lds	r31, 0x2057
 2b0:	30 97       	sbiw	r30, 0x00	; 0
 2b2:	09 f0       	breq	.+2      	; 0x2b6 <__vector_15+0x30>
		tc_tcc0_err_callback();
 2b4:	09 95       	icall
	}
}
 2b6:	ff 91       	pop	r31
 2b8:	ef 91       	pop	r30
 2ba:	bf 91       	pop	r27
 2bc:	af 91       	pop	r26
 2be:	9f 91       	pop	r25
 2c0:	8f 91       	pop	r24
 2c2:	7f 91       	pop	r23
 2c4:	6f 91       	pop	r22
 2c6:	5f 91       	pop	r21
 2c8:	4f 91       	pop	r20
 2ca:	3f 91       	pop	r19
 2cc:	2f 91       	pop	r18
 2ce:	0f 90       	pop	r0
 2d0:	0f be       	out	0x3f, r0	; 63
 2d2:	0f 90       	pop	r0
 2d4:	1f 90       	pop	r1
 2d6:	18 95       	reti

000002d8 <__vector_16>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureA and
 * call the callback function.
 */
ISR(TCC0_CCA_vect)
{
 2d8:	1f 92       	push	r1
 2da:	0f 92       	push	r0
 2dc:	0f b6       	in	r0, 0x3f	; 63
 2de:	0f 92       	push	r0
 2e0:	11 24       	eor	r1, r1
 2e2:	2f 93       	push	r18
 2e4:	3f 93       	push	r19
 2e6:	4f 93       	push	r20
 2e8:	5f 93       	push	r21
 2ea:	6f 93       	push	r22
 2ec:	7f 93       	push	r23
 2ee:	8f 93       	push	r24
 2f0:	9f 93       	push	r25
 2f2:	af 93       	push	r26
 2f4:	bf 93       	push	r27
 2f6:	ef 93       	push	r30
 2f8:	ff 93       	push	r31
	if (tc_tcc0_cca_callback) {
 2fa:	e0 91 54 20 	lds	r30, 0x2054
 2fe:	f0 91 55 20 	lds	r31, 0x2055
 302:	30 97       	sbiw	r30, 0x00	; 0
 304:	09 f0       	breq	.+2      	; 0x308 <__vector_16+0x30>
		tc_tcc0_cca_callback();
 306:	09 95       	icall
	}
}
 308:	ff 91       	pop	r31
 30a:	ef 91       	pop	r30
 30c:	bf 91       	pop	r27
 30e:	af 91       	pop	r26
 310:	9f 91       	pop	r25
 312:	8f 91       	pop	r24
 314:	7f 91       	pop	r23
 316:	6f 91       	pop	r22
 318:	5f 91       	pop	r21
 31a:	4f 91       	pop	r20
 31c:	3f 91       	pop	r19
 31e:	2f 91       	pop	r18
 320:	0f 90       	pop	r0
 322:	0f be       	out	0x3f, r0	; 63
 324:	0f 90       	pop	r0
 326:	1f 90       	pop	r1
 328:	18 95       	reti

0000032a <__vector_17>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureB and
 * call the callback function.
 */
ISR(TCC0_CCB_vect)
{
 32a:	1f 92       	push	r1
 32c:	0f 92       	push	r0
 32e:	0f b6       	in	r0, 0x3f	; 63
 330:	0f 92       	push	r0
 332:	11 24       	eor	r1, r1
 334:	2f 93       	push	r18
 336:	3f 93       	push	r19
 338:	4f 93       	push	r20
 33a:	5f 93       	push	r21
 33c:	6f 93       	push	r22
 33e:	7f 93       	push	r23
 340:	8f 93       	push	r24
 342:	9f 93       	push	r25
 344:	af 93       	push	r26
 346:	bf 93       	push	r27
 348:	ef 93       	push	r30
 34a:	ff 93       	push	r31
	if (tc_tcc0_ccb_callback) {
 34c:	e0 91 52 20 	lds	r30, 0x2052
 350:	f0 91 53 20 	lds	r31, 0x2053
 354:	30 97       	sbiw	r30, 0x00	; 0
 356:	09 f0       	breq	.+2      	; 0x35a <__vector_17+0x30>
		tc_tcc0_ccb_callback();
 358:	09 95       	icall
	}
}
 35a:	ff 91       	pop	r31
 35c:	ef 91       	pop	r30
 35e:	bf 91       	pop	r27
 360:	af 91       	pop	r26
 362:	9f 91       	pop	r25
 364:	8f 91       	pop	r24
 366:	7f 91       	pop	r23
 368:	6f 91       	pop	r22
 36a:	5f 91       	pop	r21
 36c:	4f 91       	pop	r20
 36e:	3f 91       	pop	r19
 370:	2f 91       	pop	r18
 372:	0f 90       	pop	r0
 374:	0f be       	out	0x3f, r0	; 63
 376:	0f 90       	pop	r0
 378:	1f 90       	pop	r1
 37a:	18 95       	reti

0000037c <__vector_18>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureC and
 * call the callback function.
 */
ISR(TCC0_CCC_vect)
{
 37c:	1f 92       	push	r1
 37e:	0f 92       	push	r0
 380:	0f b6       	in	r0, 0x3f	; 63
 382:	0f 92       	push	r0
 384:	11 24       	eor	r1, r1
 386:	2f 93       	push	r18
 388:	3f 93       	push	r19
 38a:	4f 93       	push	r20
 38c:	5f 93       	push	r21
 38e:	6f 93       	push	r22
 390:	7f 93       	push	r23
 392:	8f 93       	push	r24
 394:	9f 93       	push	r25
 396:	af 93       	push	r26
 398:	bf 93       	push	r27
 39a:	ef 93       	push	r30
 39c:	ff 93       	push	r31
	if (tc_tcc0_ccc_callback) {
 39e:	e0 91 50 20 	lds	r30, 0x2050
 3a2:	f0 91 51 20 	lds	r31, 0x2051
 3a6:	30 97       	sbiw	r30, 0x00	; 0
 3a8:	09 f0       	breq	.+2      	; 0x3ac <__vector_18+0x30>
		tc_tcc0_ccc_callback();
 3aa:	09 95       	icall
	}
}
 3ac:	ff 91       	pop	r31
 3ae:	ef 91       	pop	r30
 3b0:	bf 91       	pop	r27
 3b2:	af 91       	pop	r26
 3b4:	9f 91       	pop	r25
 3b6:	8f 91       	pop	r24
 3b8:	7f 91       	pop	r23
 3ba:	6f 91       	pop	r22
 3bc:	5f 91       	pop	r21
 3be:	4f 91       	pop	r20
 3c0:	3f 91       	pop	r19
 3c2:	2f 91       	pop	r18
 3c4:	0f 90       	pop	r0
 3c6:	0f be       	out	0x3f, r0	; 63
 3c8:	0f 90       	pop	r0
 3ca:	1f 90       	pop	r1
 3cc:	18 95       	reti

000003ce <__vector_19>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureD and
 * call the callback function.
 */
ISR(TCC0_CCD_vect)
{
 3ce:	1f 92       	push	r1
 3d0:	0f 92       	push	r0
 3d2:	0f b6       	in	r0, 0x3f	; 63
 3d4:	0f 92       	push	r0
 3d6:	11 24       	eor	r1, r1
 3d8:	2f 93       	push	r18
 3da:	3f 93       	push	r19
 3dc:	4f 93       	push	r20
 3de:	5f 93       	push	r21
 3e0:	6f 93       	push	r22
 3e2:	7f 93       	push	r23
 3e4:	8f 93       	push	r24
 3e6:	9f 93       	push	r25
 3e8:	af 93       	push	r26
 3ea:	bf 93       	push	r27
 3ec:	ef 93       	push	r30
 3ee:	ff 93       	push	r31
	if (tc_tcc0_ccd_callback) {
 3f0:	e0 91 4e 20 	lds	r30, 0x204E
 3f4:	f0 91 4f 20 	lds	r31, 0x204F
 3f8:	30 97       	sbiw	r30, 0x00	; 0
 3fa:	09 f0       	breq	.+2      	; 0x3fe <__vector_19+0x30>
		tc_tcc0_ccd_callback();
 3fc:	09 95       	icall
	}
}
 3fe:	ff 91       	pop	r31
 400:	ef 91       	pop	r30
 402:	bf 91       	pop	r27
 404:	af 91       	pop	r26
 406:	9f 91       	pop	r25
 408:	8f 91       	pop	r24
 40a:	7f 91       	pop	r23
 40c:	6f 91       	pop	r22
 40e:	5f 91       	pop	r21
 410:	4f 91       	pop	r20
 412:	3f 91       	pop	r19
 414:	2f 91       	pop	r18
 416:	0f 90       	pop	r0
 418:	0f be       	out	0x3f, r0	; 63
 41a:	0f 90       	pop	r0
 41c:	1f 90       	pop	r1
 41e:	18 95       	reti

00000420 <__vector_20>:
 *
 * This function will handle interrupt on Timer Counter C1 overflow and
 * call the callback function.
 */
ISR(TCC1_OVF_vect)
{
 420:	1f 92       	push	r1
 422:	0f 92       	push	r0
 424:	0f b6       	in	r0, 0x3f	; 63
 426:	0f 92       	push	r0
 428:	11 24       	eor	r1, r1
 42a:	2f 93       	push	r18
 42c:	3f 93       	push	r19
 42e:	4f 93       	push	r20
 430:	5f 93       	push	r21
 432:	6f 93       	push	r22
 434:	7f 93       	push	r23
 436:	8f 93       	push	r24
 438:	9f 93       	push	r25
 43a:	af 93       	push	r26
 43c:	bf 93       	push	r27
 43e:	ef 93       	push	r30
 440:	ff 93       	push	r31
	if (tc_tcc1_ovf_callback) {
 442:	e0 91 4c 20 	lds	r30, 0x204C
 446:	f0 91 4d 20 	lds	r31, 0x204D
 44a:	30 97       	sbiw	r30, 0x00	; 0
 44c:	09 f0       	breq	.+2      	; 0x450 <__vector_20+0x30>
		tc_tcc1_ovf_callback();
 44e:	09 95       	icall
	}
}
 450:	ff 91       	pop	r31
 452:	ef 91       	pop	r30
 454:	bf 91       	pop	r27
 456:	af 91       	pop	r26
 458:	9f 91       	pop	r25
 45a:	8f 91       	pop	r24
 45c:	7f 91       	pop	r23
 45e:	6f 91       	pop	r22
 460:	5f 91       	pop	r21
 462:	4f 91       	pop	r20
 464:	3f 91       	pop	r19
 466:	2f 91       	pop	r18
 468:	0f 90       	pop	r0
 46a:	0f be       	out	0x3f, r0	; 63
 46c:	0f 90       	pop	r0
 46e:	1f 90       	pop	r1
 470:	18 95       	reti

00000472 <__vector_21>:
 *
 * This function will handle interrupt on Timer Counter C1 error and
 * call the callback function.
 */
ISR(TCC1_ERR_vect)
{
 472:	1f 92       	push	r1
 474:	0f 92       	push	r0
 476:	0f b6       	in	r0, 0x3f	; 63
 478:	0f 92       	push	r0
 47a:	11 24       	eor	r1, r1
 47c:	2f 93       	push	r18
 47e:	3f 93       	push	r19
 480:	4f 93       	push	r20
 482:	5f 93       	push	r21
 484:	6f 93       	push	r22
 486:	7f 93       	push	r23
 488:	8f 93       	push	r24
 48a:	9f 93       	push	r25
 48c:	af 93       	push	r26
 48e:	bf 93       	push	r27
 490:	ef 93       	push	r30
 492:	ff 93       	push	r31
	if (tc_tcc1_err_callback) {
 494:	e0 91 4a 20 	lds	r30, 0x204A
 498:	f0 91 4b 20 	lds	r31, 0x204B
 49c:	30 97       	sbiw	r30, 0x00	; 0
 49e:	09 f0       	breq	.+2      	; 0x4a2 <__vector_21+0x30>
		tc_tcc1_err_callback();
 4a0:	09 95       	icall
	}
}
 4a2:	ff 91       	pop	r31
 4a4:	ef 91       	pop	r30
 4a6:	bf 91       	pop	r27
 4a8:	af 91       	pop	r26
 4aa:	9f 91       	pop	r25
 4ac:	8f 91       	pop	r24
 4ae:	7f 91       	pop	r23
 4b0:	6f 91       	pop	r22
 4b2:	5f 91       	pop	r21
 4b4:	4f 91       	pop	r20
 4b6:	3f 91       	pop	r19
 4b8:	2f 91       	pop	r18
 4ba:	0f 90       	pop	r0
 4bc:	0f be       	out	0x3f, r0	; 63
 4be:	0f 90       	pop	r0
 4c0:	1f 90       	pop	r1
 4c2:	18 95       	reti

000004c4 <__vector_22>:
 *
 * This function will handle interrupt on Timer Counter C1 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCC1_CCA_vect)
{
 4c4:	1f 92       	push	r1
 4c6:	0f 92       	push	r0
 4c8:	0f b6       	in	r0, 0x3f	; 63
 4ca:	0f 92       	push	r0
 4cc:	11 24       	eor	r1, r1
 4ce:	2f 93       	push	r18
 4d0:	3f 93       	push	r19
 4d2:	4f 93       	push	r20
 4d4:	5f 93       	push	r21
 4d6:	6f 93       	push	r22
 4d8:	7f 93       	push	r23
 4da:	8f 93       	push	r24
 4dc:	9f 93       	push	r25
 4de:	af 93       	push	r26
 4e0:	bf 93       	push	r27
 4e2:	ef 93       	push	r30
 4e4:	ff 93       	push	r31
	if (tc_tcc1_cca_callback) {
 4e6:	e0 91 48 20 	lds	r30, 0x2048
 4ea:	f0 91 49 20 	lds	r31, 0x2049
 4ee:	30 97       	sbiw	r30, 0x00	; 0
 4f0:	09 f0       	breq	.+2      	; 0x4f4 <__vector_22+0x30>
		tc_tcc1_cca_callback();
 4f2:	09 95       	icall
	}
}
 4f4:	ff 91       	pop	r31
 4f6:	ef 91       	pop	r30
 4f8:	bf 91       	pop	r27
 4fa:	af 91       	pop	r26
 4fc:	9f 91       	pop	r25
 4fe:	8f 91       	pop	r24
 500:	7f 91       	pop	r23
 502:	6f 91       	pop	r22
 504:	5f 91       	pop	r21
 506:	4f 91       	pop	r20
 508:	3f 91       	pop	r19
 50a:	2f 91       	pop	r18
 50c:	0f 90       	pop	r0
 50e:	0f be       	out	0x3f, r0	; 63
 510:	0f 90       	pop	r0
 512:	1f 90       	pop	r1
 514:	18 95       	reti

00000516 <__vector_23>:
 *
 * This function will handle interrupt on Timer Counter C1 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCC1_CCB_vect)
{
 516:	1f 92       	push	r1
 518:	0f 92       	push	r0
 51a:	0f b6       	in	r0, 0x3f	; 63
 51c:	0f 92       	push	r0
 51e:	11 24       	eor	r1, r1
 520:	2f 93       	push	r18
 522:	3f 93       	push	r19
 524:	4f 93       	push	r20
 526:	5f 93       	push	r21
 528:	6f 93       	push	r22
 52a:	7f 93       	push	r23
 52c:	8f 93       	push	r24
 52e:	9f 93       	push	r25
 530:	af 93       	push	r26
 532:	bf 93       	push	r27
 534:	ef 93       	push	r30
 536:	ff 93       	push	r31
	if (tc_tcc1_ccb_callback) {
 538:	e0 91 46 20 	lds	r30, 0x2046
 53c:	f0 91 47 20 	lds	r31, 0x2047
 540:	30 97       	sbiw	r30, 0x00	; 0
 542:	09 f0       	breq	.+2      	; 0x546 <__vector_23+0x30>
		tc_tcc1_ccb_callback();
 544:	09 95       	icall
	}
}
 546:	ff 91       	pop	r31
 548:	ef 91       	pop	r30
 54a:	bf 91       	pop	r27
 54c:	af 91       	pop	r26
 54e:	9f 91       	pop	r25
 550:	8f 91       	pop	r24
 552:	7f 91       	pop	r23
 554:	6f 91       	pop	r22
 556:	5f 91       	pop	r21
 558:	4f 91       	pop	r20
 55a:	3f 91       	pop	r19
 55c:	2f 91       	pop	r18
 55e:	0f 90       	pop	r0
 560:	0f be       	out	0x3f, r0	; 63
 562:	0f 90       	pop	r0
 564:	1f 90       	pop	r1
 566:	18 95       	reti

00000568 <__vector_77>:
 *
 * This function will handle interrupt on Timer Counter D0 overflow and
 * call the callback function.
 */
ISR(TCD0_OVF_vect)
{
 568:	1f 92       	push	r1
 56a:	0f 92       	push	r0
 56c:	0f b6       	in	r0, 0x3f	; 63
 56e:	0f 92       	push	r0
 570:	11 24       	eor	r1, r1
 572:	2f 93       	push	r18
 574:	3f 93       	push	r19
 576:	4f 93       	push	r20
 578:	5f 93       	push	r21
 57a:	6f 93       	push	r22
 57c:	7f 93       	push	r23
 57e:	8f 93       	push	r24
 580:	9f 93       	push	r25
 582:	af 93       	push	r26
 584:	bf 93       	push	r27
 586:	ef 93       	push	r30
 588:	ff 93       	push	r31
	if (tc_tcd0_ovf_callback) {
 58a:	e0 91 44 20 	lds	r30, 0x2044
 58e:	f0 91 45 20 	lds	r31, 0x2045
 592:	30 97       	sbiw	r30, 0x00	; 0
 594:	09 f0       	breq	.+2      	; 0x598 <__vector_77+0x30>
		tc_tcd0_ovf_callback();
 596:	09 95       	icall
	}
}
 598:	ff 91       	pop	r31
 59a:	ef 91       	pop	r30
 59c:	bf 91       	pop	r27
 59e:	af 91       	pop	r26
 5a0:	9f 91       	pop	r25
 5a2:	8f 91       	pop	r24
 5a4:	7f 91       	pop	r23
 5a6:	6f 91       	pop	r22
 5a8:	5f 91       	pop	r21
 5aa:	4f 91       	pop	r20
 5ac:	3f 91       	pop	r19
 5ae:	2f 91       	pop	r18
 5b0:	0f 90       	pop	r0
 5b2:	0f be       	out	0x3f, r0	; 63
 5b4:	0f 90       	pop	r0
 5b6:	1f 90       	pop	r1
 5b8:	18 95       	reti

000005ba <__vector_78>:
 *
 * This function will handle interrupt on Timer Counter D0 error and
 * call the callback function.
 */
ISR(TCD0_ERR_vect)
{
 5ba:	1f 92       	push	r1
 5bc:	0f 92       	push	r0
 5be:	0f b6       	in	r0, 0x3f	; 63
 5c0:	0f 92       	push	r0
 5c2:	11 24       	eor	r1, r1
 5c4:	2f 93       	push	r18
 5c6:	3f 93       	push	r19
 5c8:	4f 93       	push	r20
 5ca:	5f 93       	push	r21
 5cc:	6f 93       	push	r22
 5ce:	7f 93       	push	r23
 5d0:	8f 93       	push	r24
 5d2:	9f 93       	push	r25
 5d4:	af 93       	push	r26
 5d6:	bf 93       	push	r27
 5d8:	ef 93       	push	r30
 5da:	ff 93       	push	r31
	if (tc_tcd0_err_callback) {
 5dc:	e0 91 42 20 	lds	r30, 0x2042
 5e0:	f0 91 43 20 	lds	r31, 0x2043
 5e4:	30 97       	sbiw	r30, 0x00	; 0
 5e6:	09 f0       	breq	.+2      	; 0x5ea <__vector_78+0x30>
		tc_tcd0_err_callback();
 5e8:	09 95       	icall
	}
}
 5ea:	ff 91       	pop	r31
 5ec:	ef 91       	pop	r30
 5ee:	bf 91       	pop	r27
 5f0:	af 91       	pop	r26
 5f2:	9f 91       	pop	r25
 5f4:	8f 91       	pop	r24
 5f6:	7f 91       	pop	r23
 5f8:	6f 91       	pop	r22
 5fa:	5f 91       	pop	r21
 5fc:	4f 91       	pop	r20
 5fe:	3f 91       	pop	r19
 600:	2f 91       	pop	r18
 602:	0f 90       	pop	r0
 604:	0f be       	out	0x3f, r0	; 63
 606:	0f 90       	pop	r0
 608:	1f 90       	pop	r1
 60a:	18 95       	reti

0000060c <__vector_79>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCD0_CCA_vect)
{
 60c:	1f 92       	push	r1
 60e:	0f 92       	push	r0
 610:	0f b6       	in	r0, 0x3f	; 63
 612:	0f 92       	push	r0
 614:	11 24       	eor	r1, r1
 616:	2f 93       	push	r18
 618:	3f 93       	push	r19
 61a:	4f 93       	push	r20
 61c:	5f 93       	push	r21
 61e:	6f 93       	push	r22
 620:	7f 93       	push	r23
 622:	8f 93       	push	r24
 624:	9f 93       	push	r25
 626:	af 93       	push	r26
 628:	bf 93       	push	r27
 62a:	ef 93       	push	r30
 62c:	ff 93       	push	r31
	if (tc_tcd0_cca_callback) {
 62e:	e0 91 40 20 	lds	r30, 0x2040
 632:	f0 91 41 20 	lds	r31, 0x2041
 636:	30 97       	sbiw	r30, 0x00	; 0
 638:	09 f0       	breq	.+2      	; 0x63c <__vector_79+0x30>
		tc_tcd0_cca_callback();
 63a:	09 95       	icall
	}
}
 63c:	ff 91       	pop	r31
 63e:	ef 91       	pop	r30
 640:	bf 91       	pop	r27
 642:	af 91       	pop	r26
 644:	9f 91       	pop	r25
 646:	8f 91       	pop	r24
 648:	7f 91       	pop	r23
 64a:	6f 91       	pop	r22
 64c:	5f 91       	pop	r21
 64e:	4f 91       	pop	r20
 650:	3f 91       	pop	r19
 652:	2f 91       	pop	r18
 654:	0f 90       	pop	r0
 656:	0f be       	out	0x3f, r0	; 63
 658:	0f 90       	pop	r0
 65a:	1f 90       	pop	r1
 65c:	18 95       	reti

0000065e <__vector_80>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCD0_CCB_vect)
{
 65e:	1f 92       	push	r1
 660:	0f 92       	push	r0
 662:	0f b6       	in	r0, 0x3f	; 63
 664:	0f 92       	push	r0
 666:	11 24       	eor	r1, r1
 668:	2f 93       	push	r18
 66a:	3f 93       	push	r19
 66c:	4f 93       	push	r20
 66e:	5f 93       	push	r21
 670:	6f 93       	push	r22
 672:	7f 93       	push	r23
 674:	8f 93       	push	r24
 676:	9f 93       	push	r25
 678:	af 93       	push	r26
 67a:	bf 93       	push	r27
 67c:	ef 93       	push	r30
 67e:	ff 93       	push	r31
	if (tc_tcd0_ccb_callback) {
 680:	e0 91 3e 20 	lds	r30, 0x203E
 684:	f0 91 3f 20 	lds	r31, 0x203F
 688:	30 97       	sbiw	r30, 0x00	; 0
 68a:	09 f0       	breq	.+2      	; 0x68e <__vector_80+0x30>
		tc_tcd0_ccb_callback();
 68c:	09 95       	icall
	}
}
 68e:	ff 91       	pop	r31
 690:	ef 91       	pop	r30
 692:	bf 91       	pop	r27
 694:	af 91       	pop	r26
 696:	9f 91       	pop	r25
 698:	8f 91       	pop	r24
 69a:	7f 91       	pop	r23
 69c:	6f 91       	pop	r22
 69e:	5f 91       	pop	r21
 6a0:	4f 91       	pop	r20
 6a2:	3f 91       	pop	r19
 6a4:	2f 91       	pop	r18
 6a6:	0f 90       	pop	r0
 6a8:	0f be       	out	0x3f, r0	; 63
 6aa:	0f 90       	pop	r0
 6ac:	1f 90       	pop	r1
 6ae:	18 95       	reti

000006b0 <__vector_81>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureC and
 * call the callback function.
 */
ISR(TCD0_CCC_vect)
{
 6b0:	1f 92       	push	r1
 6b2:	0f 92       	push	r0
 6b4:	0f b6       	in	r0, 0x3f	; 63
 6b6:	0f 92       	push	r0
 6b8:	11 24       	eor	r1, r1
 6ba:	2f 93       	push	r18
 6bc:	3f 93       	push	r19
 6be:	4f 93       	push	r20
 6c0:	5f 93       	push	r21
 6c2:	6f 93       	push	r22
 6c4:	7f 93       	push	r23
 6c6:	8f 93       	push	r24
 6c8:	9f 93       	push	r25
 6ca:	af 93       	push	r26
 6cc:	bf 93       	push	r27
 6ce:	ef 93       	push	r30
 6d0:	ff 93       	push	r31
	if (tc_tcd0_ccc_callback) {
 6d2:	e0 91 3c 20 	lds	r30, 0x203C
 6d6:	f0 91 3d 20 	lds	r31, 0x203D
 6da:	30 97       	sbiw	r30, 0x00	; 0
 6dc:	09 f0       	breq	.+2      	; 0x6e0 <__vector_81+0x30>
		tc_tcd0_ccc_callback();
 6de:	09 95       	icall
	}
}
 6e0:	ff 91       	pop	r31
 6e2:	ef 91       	pop	r30
 6e4:	bf 91       	pop	r27
 6e6:	af 91       	pop	r26
 6e8:	9f 91       	pop	r25
 6ea:	8f 91       	pop	r24
 6ec:	7f 91       	pop	r23
 6ee:	6f 91       	pop	r22
 6f0:	5f 91       	pop	r21
 6f2:	4f 91       	pop	r20
 6f4:	3f 91       	pop	r19
 6f6:	2f 91       	pop	r18
 6f8:	0f 90       	pop	r0
 6fa:	0f be       	out	0x3f, r0	; 63
 6fc:	0f 90       	pop	r0
 6fe:	1f 90       	pop	r1
 700:	18 95       	reti

00000702 <__vector_82>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureD and
 * call the callback function.
 */
ISR(TCD0_CCD_vect)
{
 702:	1f 92       	push	r1
 704:	0f 92       	push	r0
 706:	0f b6       	in	r0, 0x3f	; 63
 708:	0f 92       	push	r0
 70a:	11 24       	eor	r1, r1
 70c:	2f 93       	push	r18
 70e:	3f 93       	push	r19
 710:	4f 93       	push	r20
 712:	5f 93       	push	r21
 714:	6f 93       	push	r22
 716:	7f 93       	push	r23
 718:	8f 93       	push	r24
 71a:	9f 93       	push	r25
 71c:	af 93       	push	r26
 71e:	bf 93       	push	r27
 720:	ef 93       	push	r30
 722:	ff 93       	push	r31
	if (tc_tcd0_ccd_callback) {
 724:	e0 91 3a 20 	lds	r30, 0x203A
 728:	f0 91 3b 20 	lds	r31, 0x203B
 72c:	30 97       	sbiw	r30, 0x00	; 0
 72e:	09 f0       	breq	.+2      	; 0x732 <__vector_82+0x30>
		tc_tcd0_ccd_callback();
 730:	09 95       	icall
	}
}
 732:	ff 91       	pop	r31
 734:	ef 91       	pop	r30
 736:	bf 91       	pop	r27
 738:	af 91       	pop	r26
 73a:	9f 91       	pop	r25
 73c:	8f 91       	pop	r24
 73e:	7f 91       	pop	r23
 740:	6f 91       	pop	r22
 742:	5f 91       	pop	r21
 744:	4f 91       	pop	r20
 746:	3f 91       	pop	r19
 748:	2f 91       	pop	r18
 74a:	0f 90       	pop	r0
 74c:	0f be       	out	0x3f, r0	; 63
 74e:	0f 90       	pop	r0
 750:	1f 90       	pop	r1
 752:	18 95       	reti

00000754 <__vector_83>:
 *
 * This function will handle interrupt on Timer Counter D1 overflow and
 * call the callback function.
 */
ISR(TCD1_OVF_vect)
{
 754:	1f 92       	push	r1
 756:	0f 92       	push	r0
 758:	0f b6       	in	r0, 0x3f	; 63
 75a:	0f 92       	push	r0
 75c:	11 24       	eor	r1, r1
 75e:	2f 93       	push	r18
 760:	3f 93       	push	r19
 762:	4f 93       	push	r20
 764:	5f 93       	push	r21
 766:	6f 93       	push	r22
 768:	7f 93       	push	r23
 76a:	8f 93       	push	r24
 76c:	9f 93       	push	r25
 76e:	af 93       	push	r26
 770:	bf 93       	push	r27
 772:	ef 93       	push	r30
 774:	ff 93       	push	r31
	if (tc_tcd1_ovf_callback) {
 776:	e0 91 38 20 	lds	r30, 0x2038
 77a:	f0 91 39 20 	lds	r31, 0x2039
 77e:	30 97       	sbiw	r30, 0x00	; 0
 780:	09 f0       	breq	.+2      	; 0x784 <__vector_83+0x30>
		tc_tcd1_ovf_callback();
 782:	09 95       	icall
	}
}
 784:	ff 91       	pop	r31
 786:	ef 91       	pop	r30
 788:	bf 91       	pop	r27
 78a:	af 91       	pop	r26
 78c:	9f 91       	pop	r25
 78e:	8f 91       	pop	r24
 790:	7f 91       	pop	r23
 792:	6f 91       	pop	r22
 794:	5f 91       	pop	r21
 796:	4f 91       	pop	r20
 798:	3f 91       	pop	r19
 79a:	2f 91       	pop	r18
 79c:	0f 90       	pop	r0
 79e:	0f be       	out	0x3f, r0	; 63
 7a0:	0f 90       	pop	r0
 7a2:	1f 90       	pop	r1
 7a4:	18 95       	reti

000007a6 <__vector_84>:
 *
 * This function will handle interrupt on Timer Counter D1 error and
 * call the callback function.
 */
ISR(TCD1_ERR_vect)
{
 7a6:	1f 92       	push	r1
 7a8:	0f 92       	push	r0
 7aa:	0f b6       	in	r0, 0x3f	; 63
 7ac:	0f 92       	push	r0
 7ae:	11 24       	eor	r1, r1
 7b0:	2f 93       	push	r18
 7b2:	3f 93       	push	r19
 7b4:	4f 93       	push	r20
 7b6:	5f 93       	push	r21
 7b8:	6f 93       	push	r22
 7ba:	7f 93       	push	r23
 7bc:	8f 93       	push	r24
 7be:	9f 93       	push	r25
 7c0:	af 93       	push	r26
 7c2:	bf 93       	push	r27
 7c4:	ef 93       	push	r30
 7c6:	ff 93       	push	r31
	if (tc_tcd1_err_callback) {
 7c8:	e0 91 36 20 	lds	r30, 0x2036
 7cc:	f0 91 37 20 	lds	r31, 0x2037
 7d0:	30 97       	sbiw	r30, 0x00	; 0
 7d2:	09 f0       	breq	.+2      	; 0x7d6 <__vector_84+0x30>
		tc_tcd1_err_callback();
 7d4:	09 95       	icall
	}
}
 7d6:	ff 91       	pop	r31
 7d8:	ef 91       	pop	r30
 7da:	bf 91       	pop	r27
 7dc:	af 91       	pop	r26
 7de:	9f 91       	pop	r25
 7e0:	8f 91       	pop	r24
 7e2:	7f 91       	pop	r23
 7e4:	6f 91       	pop	r22
 7e6:	5f 91       	pop	r21
 7e8:	4f 91       	pop	r20
 7ea:	3f 91       	pop	r19
 7ec:	2f 91       	pop	r18
 7ee:	0f 90       	pop	r0
 7f0:	0f be       	out	0x3f, r0	; 63
 7f2:	0f 90       	pop	r0
 7f4:	1f 90       	pop	r1
 7f6:	18 95       	reti

000007f8 <__vector_85>:
 *
 * This function will handle interrupt on Timer Counter D1 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCD1_CCA_vect)
{
 7f8:	1f 92       	push	r1
 7fa:	0f 92       	push	r0
 7fc:	0f b6       	in	r0, 0x3f	; 63
 7fe:	0f 92       	push	r0
 800:	11 24       	eor	r1, r1
 802:	2f 93       	push	r18
 804:	3f 93       	push	r19
 806:	4f 93       	push	r20
 808:	5f 93       	push	r21
 80a:	6f 93       	push	r22
 80c:	7f 93       	push	r23
 80e:	8f 93       	push	r24
 810:	9f 93       	push	r25
 812:	af 93       	push	r26
 814:	bf 93       	push	r27
 816:	ef 93       	push	r30
 818:	ff 93       	push	r31
	if (tc_tcd1_cca_callback) {
 81a:	e0 91 34 20 	lds	r30, 0x2034
 81e:	f0 91 35 20 	lds	r31, 0x2035
 822:	30 97       	sbiw	r30, 0x00	; 0
 824:	09 f0       	breq	.+2      	; 0x828 <__vector_85+0x30>
		tc_tcd1_cca_callback();
 826:	09 95       	icall
	}
}
 828:	ff 91       	pop	r31
 82a:	ef 91       	pop	r30
 82c:	bf 91       	pop	r27
 82e:	af 91       	pop	r26
 830:	9f 91       	pop	r25
 832:	8f 91       	pop	r24
 834:	7f 91       	pop	r23
 836:	6f 91       	pop	r22
 838:	5f 91       	pop	r21
 83a:	4f 91       	pop	r20
 83c:	3f 91       	pop	r19
 83e:	2f 91       	pop	r18
 840:	0f 90       	pop	r0
 842:	0f be       	out	0x3f, r0	; 63
 844:	0f 90       	pop	r0
 846:	1f 90       	pop	r1
 848:	18 95       	reti

0000084a <__vector_86>:
 *
 * This function will handle interrupt on Timer Counter D1 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCD1_CCB_vect)
{
 84a:	1f 92       	push	r1
 84c:	0f 92       	push	r0
 84e:	0f b6       	in	r0, 0x3f	; 63
 850:	0f 92       	push	r0
 852:	11 24       	eor	r1, r1
 854:	2f 93       	push	r18
 856:	3f 93       	push	r19
 858:	4f 93       	push	r20
 85a:	5f 93       	push	r21
 85c:	6f 93       	push	r22
 85e:	7f 93       	push	r23
 860:	8f 93       	push	r24
 862:	9f 93       	push	r25
 864:	af 93       	push	r26
 866:	bf 93       	push	r27
 868:	ef 93       	push	r30
 86a:	ff 93       	push	r31
	if (tc_tcd1_ccb_callback) {
 86c:	e0 91 32 20 	lds	r30, 0x2032
 870:	f0 91 33 20 	lds	r31, 0x2033
 874:	30 97       	sbiw	r30, 0x00	; 0
 876:	09 f0       	breq	.+2      	; 0x87a <__vector_86+0x30>
		tc_tcd1_ccb_callback();
 878:	09 95       	icall
	}
}
 87a:	ff 91       	pop	r31
 87c:	ef 91       	pop	r30
 87e:	bf 91       	pop	r27
 880:	af 91       	pop	r26
 882:	9f 91       	pop	r25
 884:	8f 91       	pop	r24
 886:	7f 91       	pop	r23
 888:	6f 91       	pop	r22
 88a:	5f 91       	pop	r21
 88c:	4f 91       	pop	r20
 88e:	3f 91       	pop	r19
 890:	2f 91       	pop	r18
 892:	0f 90       	pop	r0
 894:	0f be       	out	0x3f, r0	; 63
 896:	0f 90       	pop	r0
 898:	1f 90       	pop	r1
 89a:	18 95       	reti

0000089c <__vector_47>:
 *
 * This function will handle interrupt on Timer Counter E0 overflow and
 * call the callback function.
 */
ISR(TCE0_OVF_vect)
{
 89c:	1f 92       	push	r1
 89e:	0f 92       	push	r0
 8a0:	0f b6       	in	r0, 0x3f	; 63
 8a2:	0f 92       	push	r0
 8a4:	11 24       	eor	r1, r1
 8a6:	2f 93       	push	r18
 8a8:	3f 93       	push	r19
 8aa:	4f 93       	push	r20
 8ac:	5f 93       	push	r21
 8ae:	6f 93       	push	r22
 8b0:	7f 93       	push	r23
 8b2:	8f 93       	push	r24
 8b4:	9f 93       	push	r25
 8b6:	af 93       	push	r26
 8b8:	bf 93       	push	r27
 8ba:	ef 93       	push	r30
 8bc:	ff 93       	push	r31
	if (tc_tce0_ovf_callback) {
 8be:	e0 91 30 20 	lds	r30, 0x2030
 8c2:	f0 91 31 20 	lds	r31, 0x2031
 8c6:	30 97       	sbiw	r30, 0x00	; 0
 8c8:	09 f0       	breq	.+2      	; 0x8cc <__vector_47+0x30>
		tc_tce0_ovf_callback();
 8ca:	09 95       	icall
	}
}
 8cc:	ff 91       	pop	r31
 8ce:	ef 91       	pop	r30
 8d0:	bf 91       	pop	r27
 8d2:	af 91       	pop	r26
 8d4:	9f 91       	pop	r25
 8d6:	8f 91       	pop	r24
 8d8:	7f 91       	pop	r23
 8da:	6f 91       	pop	r22
 8dc:	5f 91       	pop	r21
 8de:	4f 91       	pop	r20
 8e0:	3f 91       	pop	r19
 8e2:	2f 91       	pop	r18
 8e4:	0f 90       	pop	r0
 8e6:	0f be       	out	0x3f, r0	; 63
 8e8:	0f 90       	pop	r0
 8ea:	1f 90       	pop	r1
 8ec:	18 95       	reti

000008ee <__vector_48>:
 *
 * This function will handle interrupt on Timer Counter E0 error and
 * call the callback function.
 */
ISR(TCE0_ERR_vect)
{
 8ee:	1f 92       	push	r1
 8f0:	0f 92       	push	r0
 8f2:	0f b6       	in	r0, 0x3f	; 63
 8f4:	0f 92       	push	r0
 8f6:	11 24       	eor	r1, r1
 8f8:	2f 93       	push	r18
 8fa:	3f 93       	push	r19
 8fc:	4f 93       	push	r20
 8fe:	5f 93       	push	r21
 900:	6f 93       	push	r22
 902:	7f 93       	push	r23
 904:	8f 93       	push	r24
 906:	9f 93       	push	r25
 908:	af 93       	push	r26
 90a:	bf 93       	push	r27
 90c:	ef 93       	push	r30
 90e:	ff 93       	push	r31
	if (tc_tce0_err_callback) {
 910:	e0 91 2e 20 	lds	r30, 0x202E
 914:	f0 91 2f 20 	lds	r31, 0x202F
 918:	30 97       	sbiw	r30, 0x00	; 0
 91a:	09 f0       	breq	.+2      	; 0x91e <__vector_48+0x30>
		tc_tce0_err_callback();
 91c:	09 95       	icall
	}
}
 91e:	ff 91       	pop	r31
 920:	ef 91       	pop	r30
 922:	bf 91       	pop	r27
 924:	af 91       	pop	r26
 926:	9f 91       	pop	r25
 928:	8f 91       	pop	r24
 92a:	7f 91       	pop	r23
 92c:	6f 91       	pop	r22
 92e:	5f 91       	pop	r21
 930:	4f 91       	pop	r20
 932:	3f 91       	pop	r19
 934:	2f 91       	pop	r18
 936:	0f 90       	pop	r0
 938:	0f be       	out	0x3f, r0	; 63
 93a:	0f 90       	pop	r0
 93c:	1f 90       	pop	r1
 93e:	18 95       	reti

00000940 <__vector_49>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCE0_CCA_vect)
{
 940:	1f 92       	push	r1
 942:	0f 92       	push	r0
 944:	0f b6       	in	r0, 0x3f	; 63
 946:	0f 92       	push	r0
 948:	11 24       	eor	r1, r1
 94a:	2f 93       	push	r18
 94c:	3f 93       	push	r19
 94e:	4f 93       	push	r20
 950:	5f 93       	push	r21
 952:	6f 93       	push	r22
 954:	7f 93       	push	r23
 956:	8f 93       	push	r24
 958:	9f 93       	push	r25
 95a:	af 93       	push	r26
 95c:	bf 93       	push	r27
 95e:	ef 93       	push	r30
 960:	ff 93       	push	r31
	if (tc_tce0_cca_callback) {
 962:	e0 91 2c 20 	lds	r30, 0x202C
 966:	f0 91 2d 20 	lds	r31, 0x202D
 96a:	30 97       	sbiw	r30, 0x00	; 0
 96c:	09 f0       	breq	.+2      	; 0x970 <__vector_49+0x30>
		tc_tce0_cca_callback();
 96e:	09 95       	icall
	}
}
 970:	ff 91       	pop	r31
 972:	ef 91       	pop	r30
 974:	bf 91       	pop	r27
 976:	af 91       	pop	r26
 978:	9f 91       	pop	r25
 97a:	8f 91       	pop	r24
 97c:	7f 91       	pop	r23
 97e:	6f 91       	pop	r22
 980:	5f 91       	pop	r21
 982:	4f 91       	pop	r20
 984:	3f 91       	pop	r19
 986:	2f 91       	pop	r18
 988:	0f 90       	pop	r0
 98a:	0f be       	out	0x3f, r0	; 63
 98c:	0f 90       	pop	r0
 98e:	1f 90       	pop	r1
 990:	18 95       	reti

00000992 <__vector_50>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCE0_CCB_vect)
{
 992:	1f 92       	push	r1
 994:	0f 92       	push	r0
 996:	0f b6       	in	r0, 0x3f	; 63
 998:	0f 92       	push	r0
 99a:	11 24       	eor	r1, r1
 99c:	2f 93       	push	r18
 99e:	3f 93       	push	r19
 9a0:	4f 93       	push	r20
 9a2:	5f 93       	push	r21
 9a4:	6f 93       	push	r22
 9a6:	7f 93       	push	r23
 9a8:	8f 93       	push	r24
 9aa:	9f 93       	push	r25
 9ac:	af 93       	push	r26
 9ae:	bf 93       	push	r27
 9b0:	ef 93       	push	r30
 9b2:	ff 93       	push	r31
	if (tc_tce0_ccb_callback) {
 9b4:	e0 91 2a 20 	lds	r30, 0x202A
 9b8:	f0 91 2b 20 	lds	r31, 0x202B
 9bc:	30 97       	sbiw	r30, 0x00	; 0
 9be:	09 f0       	breq	.+2      	; 0x9c2 <__vector_50+0x30>
		tc_tce0_ccb_callback();
 9c0:	09 95       	icall
	}
}
 9c2:	ff 91       	pop	r31
 9c4:	ef 91       	pop	r30
 9c6:	bf 91       	pop	r27
 9c8:	af 91       	pop	r26
 9ca:	9f 91       	pop	r25
 9cc:	8f 91       	pop	r24
 9ce:	7f 91       	pop	r23
 9d0:	6f 91       	pop	r22
 9d2:	5f 91       	pop	r21
 9d4:	4f 91       	pop	r20
 9d6:	3f 91       	pop	r19
 9d8:	2f 91       	pop	r18
 9da:	0f 90       	pop	r0
 9dc:	0f be       	out	0x3f, r0	; 63
 9de:	0f 90       	pop	r0
 9e0:	1f 90       	pop	r1
 9e2:	18 95       	reti

000009e4 <__vector_51>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureC and
 * call the callback function.
 */
ISR(TCE0_CCC_vect)
{
 9e4:	1f 92       	push	r1
 9e6:	0f 92       	push	r0
 9e8:	0f b6       	in	r0, 0x3f	; 63
 9ea:	0f 92       	push	r0
 9ec:	11 24       	eor	r1, r1
 9ee:	2f 93       	push	r18
 9f0:	3f 93       	push	r19
 9f2:	4f 93       	push	r20
 9f4:	5f 93       	push	r21
 9f6:	6f 93       	push	r22
 9f8:	7f 93       	push	r23
 9fa:	8f 93       	push	r24
 9fc:	9f 93       	push	r25
 9fe:	af 93       	push	r26
 a00:	bf 93       	push	r27
 a02:	ef 93       	push	r30
 a04:	ff 93       	push	r31
	if (tc_tce0_ccc_callback) {
 a06:	e0 91 28 20 	lds	r30, 0x2028
 a0a:	f0 91 29 20 	lds	r31, 0x2029
 a0e:	30 97       	sbiw	r30, 0x00	; 0
 a10:	09 f0       	breq	.+2      	; 0xa14 <__vector_51+0x30>
		tc_tce0_ccc_callback();
 a12:	09 95       	icall
	}
}
 a14:	ff 91       	pop	r31
 a16:	ef 91       	pop	r30
 a18:	bf 91       	pop	r27
 a1a:	af 91       	pop	r26
 a1c:	9f 91       	pop	r25
 a1e:	8f 91       	pop	r24
 a20:	7f 91       	pop	r23
 a22:	6f 91       	pop	r22
 a24:	5f 91       	pop	r21
 a26:	4f 91       	pop	r20
 a28:	3f 91       	pop	r19
 a2a:	2f 91       	pop	r18
 a2c:	0f 90       	pop	r0
 a2e:	0f be       	out	0x3f, r0	; 63
 a30:	0f 90       	pop	r0
 a32:	1f 90       	pop	r1
 a34:	18 95       	reti

00000a36 <__vector_52>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureD and
 * call the callback function.
 */
ISR(TCE0_CCD_vect)
{
 a36:	1f 92       	push	r1
 a38:	0f 92       	push	r0
 a3a:	0f b6       	in	r0, 0x3f	; 63
 a3c:	0f 92       	push	r0
 a3e:	11 24       	eor	r1, r1
 a40:	2f 93       	push	r18
 a42:	3f 93       	push	r19
 a44:	4f 93       	push	r20
 a46:	5f 93       	push	r21
 a48:	6f 93       	push	r22
 a4a:	7f 93       	push	r23
 a4c:	8f 93       	push	r24
 a4e:	9f 93       	push	r25
 a50:	af 93       	push	r26
 a52:	bf 93       	push	r27
 a54:	ef 93       	push	r30
 a56:	ff 93       	push	r31
	if (tc_tce0_ccd_callback) {
 a58:	e0 91 26 20 	lds	r30, 0x2026
 a5c:	f0 91 27 20 	lds	r31, 0x2027
 a60:	30 97       	sbiw	r30, 0x00	; 0
 a62:	09 f0       	breq	.+2      	; 0xa66 <__vector_52+0x30>
		tc_tce0_ccd_callback();
 a64:	09 95       	icall
	}
}
 a66:	ff 91       	pop	r31
 a68:	ef 91       	pop	r30
 a6a:	bf 91       	pop	r27
 a6c:	af 91       	pop	r26
 a6e:	9f 91       	pop	r25
 a70:	8f 91       	pop	r24
 a72:	7f 91       	pop	r23
 a74:	6f 91       	pop	r22
 a76:	5f 91       	pop	r21
 a78:	4f 91       	pop	r20
 a7a:	3f 91       	pop	r19
 a7c:	2f 91       	pop	r18
 a7e:	0f 90       	pop	r0
 a80:	0f be       	out	0x3f, r0	; 63
 a82:	0f 90       	pop	r0
 a84:	1f 90       	pop	r1
 a86:	18 95       	reti

00000a88 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
 a88:	8f ef       	ldi	r24, 0xFF	; 255
 a8a:	80 93 70 00 	sts	0x0070, r24
 a8e:	80 93 71 00 	sts	0x0071, r24
 a92:	80 93 72 00 	sts	0x0072, r24
 a96:	80 93 73 00 	sts	0x0073, r24
 a9a:	80 93 74 00 	sts	0x0074, r24
 a9e:	80 93 75 00 	sts	0x0075, r24
 aa2:	80 93 76 00 	sts	0x0076, r24

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return OSC.STATUS & OSC_PLLRDY_bm;
 aa6:	80 91 51 00 	lds	r24, 0x0051

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
 aaa:	84 fd       	sbrc	r24, 4
 aac:	1c c0       	rjmp	.+56     	; 0xae6 <sysclk_init+0x5e>

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
 aae:	80 91 51 00 	lds	r24, 0x0051
	switch (src) {
	case PLL_SRC_RC2MHZ:
		break;

	case PLL_SRC_RC32MHZ:
		if (!osc_is_ready(OSC_ID_RC32MHZ)) {
 ab2:	81 fd       	sbrc	r24, 1
 ab4:	0b c0       	rjmp	.+22     	; 0xacc <sysclk_init+0x44>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
 ab6:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
 ab8:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL |= id;
 aba:	e0 e5       	ldi	r30, 0x50	; 80
 abc:	f0 e0       	ldi	r31, 0x00	; 0
 abe:	80 81       	ld	r24, Z
 ac0:	82 60       	ori	r24, 0x02	; 2
 ac2:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 ac4:	9f bf       	out	0x3f, r25	; 63

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
 ac6:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
 ac8:	81 ff       	sbrs	r24, 1
 aca:	fd cf       	rjmp	.-6      	; 0xac6 <sysclk_init+0x3e>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
 acc:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
 ace:	f8 94       	cli
static inline void pll_config_write(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	OSC.PLLCTRL = cfg->ctrl;
 ad0:	e0 e5       	ldi	r30, 0x50	; 80
 ad2:	f0 e0       	ldi	r31, 0x00	; 0
 ad4:	83 e8       	ldi	r24, 0x83	; 131
 ad6:	85 83       	std	Z+5, r24	; 0x05

	Assert(pll_id < NR_PLLS);

	flags = cpu_irq_save();
	pll_config_write(cfg, pll_id);
	OSC.CTRL |= OSC_PLLEN_bm;
 ad8:	80 81       	ld	r24, Z
 ada:	80 61       	ori	r24, 0x10	; 16
 adc:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 ade:	9f bf       	out	0x3f, r25	; 63

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return OSC.STATUS & OSC_PLLRDY_bm;
 ae0:	81 81       	ldd	r24, Z+1	; 0x01
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
 ae2:	84 ff       	sbrs	r24, 4
 ae4:	fd cf       	rjmp	.-6      	; 0xae0 <sysclk_init+0x58>
		default:
			//unhandled_case(CONFIG_SYSCLK_SOURCE);
			return;
		}

		ccp_write_io((uint8_t *)&CLK.CTRL, CONFIG_SYSCLK_SOURCE);
 ae6:	64 e0       	ldi	r22, 0x04	; 4
 ae8:	80 e4       	ldi	r24, 0x40	; 64
 aea:	90 e0       	ldi	r25, 0x00	; 0
 aec:	09 d0       	rcall	.+18     	; 0xb00 <ccp_write_io>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
 aee:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
 af0:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL &= ~id;
 af2:	e0 e5       	ldi	r30, 0x50	; 80
 af4:	f0 e0       	ldi	r31, 0x00	; 0
 af6:	80 81       	ld	r24, Z
 af8:	8e 7f       	andi	r24, 0xFE	; 254
 afa:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
 afc:	9f bf       	out	0x3f, r25	; 63
 afe:	08 95       	ret

00000b00 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
 b00:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
 b02:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
 b04:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
 b06:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
 b08:	60 83       	st	Z, r22
	ret                             // Return to caller
 b0a:	08 95       	ret

00000b0c <board_init>:
#include <asf.h>
#include <board.h>
#include <conf_board.h>

void board_init(void)
{
 b0c:	08 95       	ret

00000b0e <__vector_66>:
int sec2[5]={0b10000001,0b01000010,0b00100100,0b00011000,0};
	
volatile int filtro;	
	
ISR(PORTA_INT0_vect)  //todos los puertos tienen 2 int 0 y 1
{
 b0e:	1f 92       	push	r1
 b10:	0f 92       	push	r0
 b12:	0f b6       	in	r0, 0x3f	; 63
 b14:	0f 92       	push	r0
 b16:	11 24       	eor	r1, r1
 b18:	2f 93       	push	r18
 b1a:	8f 93       	push	r24
 b1c:	9f 93       	push	r25
 b1e:	ef 93       	push	r30
 b20:	ff 93       	push	r31
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 b22:	2f ef       	ldi	r18, 0xFF	; 255
 b24:	8d ee       	ldi	r24, 0xED	; 237
 b26:	92 e0       	ldi	r25, 0x02	; 2
 b28:	21 50       	subi	r18, 0x01	; 1
 b2a:	80 40       	sbci	r24, 0x00	; 0
 b2c:	90 40       	sbci	r25, 0x00	; 0
 b2e:	e1 f7       	brne	.-8      	; 0xb28 <__vector_66+0x1a>
 b30:	00 c0       	rjmp	.+0      	; 0xb32 <__vector_66+0x24>
 b32:	00 00       	nop
	_delay_ms(20);
	a=0;
 b34:	10 92 5e 20 	sts	0x205E, r1
 b38:	10 92 5f 20 	sts	0x205F, r1
	filtro=(PORTA.IN & 0b00000001);
 b3c:	20 91 08 06 	lds	r18, 0x0608
 b40:	82 2f       	mov	r24, r18
 b42:	81 70       	andi	r24, 0x01	; 1
 b44:	90 e0       	ldi	r25, 0x00	; 0
 b46:	80 93 5c 20 	sts	0x205C, r24
 b4a:	90 93 5d 20 	sts	0x205D, r25
	if (filtro==1)
 b4e:	80 91 5c 20 	lds	r24, 0x205C
 b52:	90 91 5d 20 	lds	r25, 0x205D
 b56:	01 97       	sbiw	r24, 0x01	; 1
 b58:	09 f5       	brne	.+66     	; 0xb9c <__vector_66+0x8e>
	{
		LEDPORT.OUTTGL=LEDPIN;
 b5a:	81 e0       	ldi	r24, 0x01	; 1
 b5c:	80 93 e7 07 	sts	0x07E7, r24
		PORTC.OUT=sec1[i];
 b60:	e0 91 5a 20 	lds	r30, 0x205A
 b64:	f0 91 5b 20 	lds	r31, 0x205B
 b68:	ee 0f       	add	r30, r30
 b6a:	ff 1f       	adc	r31, r31
 b6c:	e6 5f       	subi	r30, 0xF6	; 246
 b6e:	ff 4d       	sbci	r31, 0xDF	; 223
 b70:	80 81       	ld	r24, Z
 b72:	80 93 44 06 	sts	0x0644, r24
		i++;
 b76:	80 91 5a 20 	lds	r24, 0x205A
 b7a:	90 91 5b 20 	lds	r25, 0x205B
 b7e:	01 96       	adiw	r24, 0x01	; 1
 b80:	80 93 5a 20 	sts	0x205A, r24
 b84:	90 93 5b 20 	sts	0x205B, r25
		if (i==14) i=0;
 b88:	80 91 5a 20 	lds	r24, 0x205A
 b8c:	90 91 5b 20 	lds	r25, 0x205B
 b90:	0e 97       	sbiw	r24, 0x0e	; 14
 b92:	21 f4       	brne	.+8      	; 0xb9c <__vector_66+0x8e>
 b94:	10 92 5a 20 	sts	0x205A, r1
 b98:	10 92 5b 20 	sts	0x205B, r1
		
	}
}
 b9c:	ff 91       	pop	r31
 b9e:	ef 91       	pop	r30
 ba0:	9f 91       	pop	r25
 ba2:	8f 91       	pop	r24
 ba4:	2f 91       	pop	r18
 ba6:	0f 90       	pop	r0
 ba8:	0f be       	out	0x3f, r0	; 63
 baa:	0f 90       	pop	r0
 bac:	1f 90       	pop	r1
 bae:	18 95       	reti

00000bb0 <__vector_67>:


ISR(PORTA_INT1_vect)
{
 bb0:	1f 92       	push	r1
 bb2:	0f 92       	push	r0
 bb4:	0f b6       	in	r0, 0x3f	; 63
 bb6:	0f 92       	push	r0
 bb8:	11 24       	eor	r1, r1
 bba:	2f 93       	push	r18
 bbc:	8f 93       	push	r24
 bbe:	9f 93       	push	r25
 bc0:	ef 93       	push	r30
 bc2:	ff 93       	push	r31
 bc4:	2f ef       	ldi	r18, 0xFF	; 255
 bc6:	8d ee       	ldi	r24, 0xED	; 237
 bc8:	92 e0       	ldi	r25, 0x02	; 2
 bca:	21 50       	subi	r18, 0x01	; 1
 bcc:	80 40       	sbci	r24, 0x00	; 0
 bce:	90 40       	sbci	r25, 0x00	; 0
 bd0:	e1 f7       	brne	.-8      	; 0xbca <__vector_67+0x1a>
 bd2:	00 c0       	rjmp	.+0      	; 0xbd4 <__vector_67+0x24>
 bd4:	00 00       	nop
	_delay_ms(20);
	i=0;
 bd6:	10 92 5a 20 	sts	0x205A, r1
 bda:	10 92 5b 20 	sts	0x205B, r1
	filtro=(PORTA.IN & 0b00000010);
 bde:	80 91 08 06 	lds	r24, 0x0608
 be2:	82 70       	andi	r24, 0x02	; 2
 be4:	90 e0       	ldi	r25, 0x00	; 0
 be6:	80 93 5c 20 	sts	0x205C, r24
 bea:	90 93 5d 20 	sts	0x205D, r25
	if (filtro==2)
 bee:	80 91 5c 20 	lds	r24, 0x205C
 bf2:	90 91 5d 20 	lds	r25, 0x205D
 bf6:	02 97       	sbiw	r24, 0x02	; 2
 bf8:	09 f5       	brne	.+66     	; 0xc3c <__vector_67+0x8c>
	{
		LEDPORT.OUTTGL=LEDPIN;
 bfa:	81 e0       	ldi	r24, 0x01	; 1
 bfc:	80 93 e7 07 	sts	0x07E7, r24
		PORTC.OUT=sec2[a];
 c00:	e0 91 5e 20 	lds	r30, 0x205E
 c04:	f0 91 5f 20 	lds	r31, 0x205F
 c08:	ee 0f       	add	r30, r30
 c0a:	ff 1f       	adc	r31, r31
 c0c:	e0 50       	subi	r30, 0x00	; 0
 c0e:	f0 4e       	sbci	r31, 0xE0	; 224
 c10:	80 81       	ld	r24, Z
 c12:	80 93 44 06 	sts	0x0644, r24
		a++;
 c16:	80 91 5e 20 	lds	r24, 0x205E
 c1a:	90 91 5f 20 	lds	r25, 0x205F
 c1e:	01 96       	adiw	r24, 0x01	; 1
 c20:	80 93 5e 20 	sts	0x205E, r24
 c24:	90 93 5f 20 	sts	0x205F, r25
		if (a==5) a=0;
 c28:	80 91 5e 20 	lds	r24, 0x205E
 c2c:	90 91 5f 20 	lds	r25, 0x205F
 c30:	05 97       	sbiw	r24, 0x05	; 5
 c32:	21 f4       	brne	.+8      	; 0xc3c <__vector_67+0x8c>
 c34:	10 92 5e 20 	sts	0x205E, r1
 c38:	10 92 5f 20 	sts	0x205F, r1
		
	}
}
 c3c:	ff 91       	pop	r31
 c3e:	ef 91       	pop	r30
 c40:	9f 91       	pop	r25
 c42:	8f 91       	pop	r24
 c44:	2f 91       	pop	r18
 c46:	0f 90       	pop	r0
 c48:	0f be       	out	0x3f, r0	; 63
 c4a:	0f 90       	pop	r0
 c4c:	1f 90       	pop	r1
 c4e:	18 95       	reti

00000c50 <main>:


int main (void)
{
	// Insert system clock initialization code here (sysclk_init()).
	sysclk_init();
 c50:	1b df       	rcall	.-458    	; 0xa88 <sysclk_init>
	board_init();
 c52:	5c df       	rcall	.-328    	; 0xb0c <board_init>
	
	PORTC.DIR=255;  //PUERTO C COMO SALIDA
 c54:	8f ef       	ldi	r24, 0xFF	; 255
 c56:	80 93 40 06 	sts	0x0640, r24
	LEDPORT.DIRSET=LEDPIN;   //LED DE LA PLACA COMO SALIDA
 c5a:	e0 ee       	ldi	r30, 0xE0	; 224
 c5c:	f7 e0       	ldi	r31, 0x07	; 7
 c5e:	81 e0       	ldi	r24, 0x01	; 1
 c60:	81 83       	std	Z+1, r24	; 0x01
	LEDPORT.OUTSET=LEDPIN; //LE ENCIENDE
 c62:	85 83       	std	Z+5, r24	; 0x05
	
	//INTERRUPCION PROGRAMMABLE MULTILEVEL INTERRUPTO CONTROLLER
	//PORTA.DIRCLR=PIN0_bm;
	//PORTA.DIRCLR=PIN1_bm;
	PORTA.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_RISING_gc;  //SE ACTIVA EL FLANCO DE SUBIDA EN EL PIN A0
 c64:	e0 e0       	ldi	r30, 0x00	; 0
 c66:	f6 e0       	ldi	r31, 0x06	; 6
 c68:	80 8b       	std	Z+16, r24	; 0x10
	PORTA.PIN1CTRL=PORT_ISC_RISING_gc; 
 c6a:	81 8b       	std	Z+17, r24	; 0x11

	PORTA.INT1MASK =0B00000010;
 c6c:	92 e0       	ldi	r25, 0x02	; 2
 c6e:	93 87       	std	Z+11, r25	; 0x0b
	//PORTA.INTCTRL |=PORT_INT1LVL_MED_gc;  //NIVEL ALTO @OJO PONER COMO OR SINO LE APGA AL OTRO@

	PORTA.INT0MASK =0B00000001; //elige a c0 como fuente de interrupcion 0
 c70:	82 87       	std	Z+10, r24	; 0x0a
	PORTA.INTCTRL |=PORT_INT0LVL_LO_gc|PORT_INT1LVL_MED_gc;   //SE INDICA EL NIVEL DE IMPORTANCIA EN MEDIO
 c72:	81 85       	ldd	r24, Z+9	; 0x09
 c74:	89 60       	ori	r24, 0x09	; 9
 c76:	81 87       	std	Z+9, r24	; 0x09

		
	//SE PUDO PONER CTRL=0B101;
	PMIC.CTRL |= PMIC_MEDLVLEN_bm; 
 c78:	e0 ea       	ldi	r30, 0xA0	; 160
 c7a:	f0 e0       	ldi	r31, 0x00	; 0
 c7c:	82 81       	ldd	r24, Z+2	; 0x02
 c7e:	82 60       	ori	r24, 0x02	; 2
 c80:	82 83       	std	Z+2, r24	; 0x02
	PMIC.CTRL |= PMIC_LOLVLEN_bm;  //UN 1 EN EL REGISTRO HABILITA EL NIVEL MEDIO Y ALTO
 c82:	82 81       	ldd	r24, Z+2	; 0x02
 c84:	81 60       	ori	r24, 0x01	; 1
 c86:	82 83       	std	Z+2, r24	; 0x02
	sei(); //habilita int globales
 c88:	78 94       	sei
	
	i=0;
 c8a:	10 92 5a 20 	sts	0x205A, r1
 c8e:	10 92 5b 20 	sts	0x205B, r1
	while (1)
	{
		
	}
 c92:	ff cf       	rjmp	.-2      	; 0xc92 <main+0x42>

00000c94 <_exit>:
 c94:	f8 94       	cli

00000c96 <__stop_program>:
 c96:	ff cf       	rjmp	.-2      	; 0xc96 <__stop_program>
